use crate::cpu::CPU;

pub fn trace(cpu: &mut CPU) -> String {
    let pc = cpu.program_counter;
    let opcode = cpu.bus.read(pc);

    let (mnemonic, len) = get_opcode_info(opcode);

    let mut hex_dump = String::new();
    for i in 0..len {
        hex_dump.push_str(&format!("{:02X} ", cpu.bus.read(pc.wrapping_add(i as u16))));
    }

    let asm_string = match len {
        1 => format!("{}", mnemonic),
        2 => format!("{} ${:02X}", mnemonic, cpu.bus.read(pc.wrapping_add(1))),
        3 => format!("{} ${:02X}{:02X}", mnemonic, cpu.bus.read(pc.wrapping_add(2)), cpu.bus.read(pc.wrapping_add(1))),
        _ => String::from("???"),
    };

    format!(
        "{:04X}  {:8} {:>14} A:{:02X} X:{:02X} Y:{:02X} P:{:02X} SP:{:02X}",
        pc, hex_dump.trim(), asm_string, cpu.register_a, cpu.register_x, cpu.register_y, cpu.status, cpu.stack_pointer
    )
}

fn get_opcode_info(opcode: u8) -> (&'static str, u8) {
    match opcode {
        // 1-Byte Instructions (Implied / Accumulator / Stack / Registers)
        0x00 => ("BRK", 1), 0x08 => ("PHP", 1), 0x0A => ("ASL A", 1), 0x18 => ("CLC", 1),
        0x28 => ("PLP", 1), 0x2A => ("ROL A", 1), 0x38 => ("SEC", 1), 0x40 => ("RTI", 1),
        0x48 => ("PHA", 1), 0x4A => ("LSR A", 1), 0x58 => ("CLI", 1), 0x60 => ("RTS", 1),
        0x68 => ("PLA", 1), 0x6A => ("ROR A", 1), 0x78 => ("SEI", 1), 0x88 => ("DEY", 1),
        0x8A => ("TXA", 1), 0x98 => ("TYA", 1), 0x9A => ("TXS", 1), 0xA8 => ("TAY", 1),
        0xAA => ("TAX", 1), 0xB8 => ("CLV", 1), 0xBA => ("TSX", 1), 0xC8 => ("INY", 1),
        0xCA => ("DEX", 1), 0xD8 => ("CLD", 1), 0xE8 => ("INX", 1), 0xEA => ("NOP", 1),
        0xF8 => ("SED", 1),

        // 2-Byte Instructions (Immediate, ZeroPage, ZeroPageX/Y, Relative, IndirectX/Y)
        0x01|0x05|0x06|0x09|0x11|0x15|0x16|0x21|0x24|0x25|0x26|0x29|0x31|0x35|0x36|0x41|
        0x45|0x46|0x49|0x51|0x55|0x56|0x61|0x65|0x66|0x69|0x71|0x75|0x76|0x81|0x84|0x85|
        0x86|0x91|0x94|0x95|0x96|0xA0|0xA1|0xA2|0xA4|0xA5|0xA6|0xA9|0xB1|0xB4|0xB5|0xB6|0xC0|
        0xC1|0xC4|0xC5|0xC6|0xC9|0xD1|0xD5|0xD6|0xE0|0xE1|0xE4|0xE5|0xE6|0xE9|0xF1|0xF5|
        0xF6 | 0x10 | 0x30 | 0x50 | 0x70 | 0x90 | 0xB0 | 0xD0 | 0xF0 => {
            let mnemonic = match opcode {
                0x01|0x05|0x09|0x11|0x15|0x19 => "ORA",
                0x21|0x25|0x29|0x31|0x35|0x39 => "AND",
                0x41|0x45|0x49|0x51|0x55|0x59 => "EOR",
                0x61|0x65|0x69|0x71|0x75|0x79 => "ADC",
                0x81|0x85|0x91|0x95 => "STA",
                0x84|0x94 => "STY", 0x86|0x96 => "STX",
                0xA0|0xA4|0xB4 => "LDY", 0xA2|0xA6|0xB6 => "LDX",
                0xA1|0xA5|0xA9|0xB1|0xB5 => "LDA",
                0xC0|0xC4 => "CPY", 0xE0|0xE4 => "CPX",
                0xC1|0xC5|0xC9|0xD1|0xD5 => "CMP",
                0xE1|0xE5|0xE9|0xF1|0xF5 => "SBC",
                0x06|0x16 => "ASL", 0x26|0x36 => "ROL",
                0x46|0x56 => "LSR", 0x66|0x76 => "ROR",
                0xC6|0xD6 => "DEC", 0xE6|0xF6 => "INC",
                0x24 => "BIT",
                0x10 => "BPL", 0x30 => "BMI", 0x50 => "BVC", 0x70 => "BVS",
                0x90 => "BCC", 0xB0 => "BCS", 0xD0 => "BNE", 0xF0 => "BEQ",
                _ => "???"
            };
            (mnemonic, 2)
        }

        // 3-Byte Instructions (Absolute, AbsoluteX/Y, Indirect)
        0x0D|0x0E|0x1D|0x1E|0x19|0x2C|0x2D|0x2E|0x3D|0x3E|0x39|0x4C|0x4D|0x4E|0x5D|0x5E|
        0x59|0x6C|0x6D|0x6E|0x7D|0x7E|0x79|0x8C|0x8D|0x8E|0x9D|0x99|0xAC|0xAD|0xAE|0xBC|
        0xBD|0xBE|0xB9|0xCC|0xCD|0xCE|0xDD|0xDE|0xD9|0xEC|0xED|0xEE|0xFD|0xFE|0xF9 | 0x20 => {
             let mnemonic = match opcode {
                0x0D|0x1D|0x19 => "ORA", 0x2D|0x3D|0x39 => "AND",
                0x4D|0x5D|0x59 => "EOR", 0x6D|0x7D|0x79 => "ADC",
                0x8D|0x9D|0x99 => "STA", 0x8C => "STY", 0x8E => "STX",
                0xAC|0xBC => "LDY", 0xAE|0xBE => "LDX", 0xAD|0xBD|0xB9 => "LDA",
                0xCC => "CPY", 0xEC => "CPX", 0xCD|0xDD|0xD9 => "CMP",
                0xED|0xFD|0xF9 => "SBC",
                0x0E|0x1E => "ASL", 0x2E|0x3E => "ROL",
                0x4E|0x5E => "LSR", 0x6E|0x7E => "ROR",
                0xCE|0xDE => "DEC", 0xEE|0xFE => "INC",
                0x2C => "BIT", 0x4C|0x6C => "JMP", 0x20 => "JSR",
                _ => "???"
            };
            (mnemonic, 3)
        }
        
        _ => ("*ILG", 1), // Illegal / Unimplemented opcode fallback
    }
}